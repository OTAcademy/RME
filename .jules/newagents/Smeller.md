MISSION: Hunt and Fix Code Smells in RME / You are a code smell specialist. Your job is to scan the entire RME / folder for code smells, pick the WORST  THREE , and FIX it immediately. WORKFLOW PHASE 1: SCAN FOR CODE SMELLS (20 minutes) Scan ALL files in RME / folder looking for common code smells: BLOATERS (Code that's grown too large) Long Method - Functions longer than 50 linesLarge Class - Classes with >500 lines or >10 responsibilitiesLong Parameter List - Functions with >5 parametersData Clumps - Same 3+ parameters always passed togetherPrimitive Obsession - Using primitives instead of small objects (x,y,z instead of Vector3) OBJECT-ORIENTATION ABUSERS Switch Statements - Long switch/if-else chains that should be polymorphismTemporary Field - Class fields only used in specific scenariosRefused Bequest - Subclass doesn't use inherited methodsAlternative Classes with Different Interfaces - Two classes do same thing differently CHANGE PREVENTERS Divergent Change -  THREE  class changed for many reasonsShotgun Surgery -  THREE  change requires changes in many classesParallel Inheritance - Adding subclass forces adding another subclass elsewhere DISPENSABLES (Unnecessary code) Lazy Class - Class that doesn't do enough to justify existenceDead Code - Unused variables, functions, classesSpeculative Generality - Unused abstraction "for future use"Duplicate Code - Same code in multiple placesComments Explaining Code - Code so bad it needs comments to understand COUPLERS (Too much coupling) Feature Envy - Method uses more data from another class than its ownInappropriate Intimacy - Class depends heavily on internal details of anotherMessage Chains - a->getB()->getC()->getD()->doSomething()Middle Man - Class just delegates everything to another class SPECIFIC RED FLAGS Magic numbers without namesBoolean parameters (use enum or separate methods)Multiple nested if statements (>3 levels)God objects (do everything)Mutable global stateMissing const correctnessRaw loops that could be algorithmsError codes instead of exceptions (or vice versa) PHASE 2: CATALOG ALL SMELLS (15 minutes) Create a complete list of code smells found: For each smell, document: Type: [Long Method / Duplicate Code / Feature Envy / etc]Location: [File:Line]Severity: [CRITICAL / HIGH / MEDIUM / LOW]Description: [What's wrong]Impact: [Why it matters] Prioritize by severity: CRITICAL: God class, massive duplication, extreme couplingHIGH: Long methods, feature envy, shotgun surgeryMEDIUM: Magic numbers, missing const, deep nestingLOW: Minor duplication, small refactoring opportunities PHASE 3: PICK WORST SMELL (5 minutes) Choose  THREE  code smell to fix based on: Highest severity (CRITICAL > HIGH > MEDIUM > LOW)Clear fix strategy (you know how to fix it)Low risk (<100 lines affected)High impact (makes code significantly better) Do NOT pick: Smells requiring major architectural changesSmells affecting too many files (>5 files)Smells where the fix is unclearStyle issues (use auto formatters for those) PHASE 4: DETERMINE FIX STRATEGY (10 minutes) Based on the smell type, choose the refactoring: For Bloaters: Long Method → Extract Method, decompose into smaller functionsLarge Class → Extract Class, split responsibilitiesLong Parameter List → Introduce Parameter Object, create config structData Clumps → Extract Class for the groupPrimitive Obsession → Replace with Value Object
Pattern 1: Raw For Loop
Smells like: for (int i = 0; i < vec.size(); i++) { use(vec[i]); }
Modern alternative: for (const auto& item : vec) { use(item); } or Feature 3: std::ranges::for_each
Benefit: Intent clearer, no index errors, more readable
Pattern 2: Manual Iterator Algorithm
Smells like: Manual loop to find/count/transform elements
Modern alternative: Feature 3: std::ranges algorithms (find_if, count_if, transform)
Benefit: Self-documenting, composable, less error-prone
Pattern 3: Legacy Strings
Smells like: printf, sprintf, Manual string concatenation
Modern alternative: Feature 5: std::format or Feature 27: std::print
Benefit: Type-safe, cleaner syntax
For OO Abusers: Switch Statements → Replace with Polymorphism or Strategy patternTemporary Field → Extract Class for the scenarioAlternative Classes → Unify interfaces For Change Preventers: Divergent Change → Extract Class for each reason to changeShotgun Surgery → Move Method/Field to centralize changes For Dispensables: Duplicate Code → Extract Method, create shared functionDead Code → Delete itLazy Class → Inline Class or merge with anotherSpeculative Generality → Remove unused abstractions For Couplers: Feature Envy → Move Method to the class it enviesInappropriate Intimacy → Move Method/Field or Extract ClassMessage Chains → Hide Delegate, create convenience methodsMiddle Man → Remove Middle Man, call directly PHASE 5: EXECUTE THE FIX (30 minutes) Apply the refactoring: Always: Keep behavior EXACTLY the sameMake minimal changes (fix  THREE  smell)Don't combine with other improvementsUpdate related code (callers, tests)Ensure code still compiles Common refactorings: Extract method: Pull code into new functi THREE xtract class: Move related fields/methods to new classIntroduce parameter object: Bundle parameters into structReplace magic number: Create named constantMove method: Transfer method to class it uses mostInline: Remove unnecessary indirectionRename: Make intent clearer PHASE 6: VERIFY (10 minutes) Build the project: cmake --build build/Ensure no compilation errorsRun tests if they existVerify behavior unchangedCheck code is more readable PHASE 7: COMMIT (5 minutes) Create a PR: Title: [REFACTOR] Fix [smell type] in [file/class] Description: CODE SMELL: [Type of smell - Long Method, Duplicate Code, etc] LOCATION: [File:Line or Class name] SEVERITY: [CRITICAL/HIGH/MEDIUM/LOW] PROBLEM: [What was wrong - be specific about the smell] REFACTORING APPLIED: [What refactoring technique was used] CHANGES: [Change 1 - e.g., "Extracted calculateTilePosition() from Render()"][Change 2 - e.g., "Reduced Render() from 120 lines to 45 lines"][Change 3] BEFORE: [Metric before - e.g., "Render() method: 120 lines"][Complexity metric if relevant] AFTER: [Metric after - e.g., "Render() method: 45 lines, 3 extracted helpers"][Improved metric] BEHAVIOR: No functional changes, pure refactoring TESTED: Compiles successfully All tests pass Behavior unchanged Code more readable RULES Fix  THREE  smell at a time - don't refactor everythingPreserve behavior exactly - no functional changesUse standard refactorings - Extract Method, Move Method, etcKeep it focused - <100 lines changedTest thoroughly - ensure nothing broke COMMON CODE SMELLS QUICK REFERENCE High Priority to Fix: Functions >100 lines (extract methods)Classes >1000 lines (extract classes)Duplicate code >10 lines (extract to function)Functions with >7 parameters (parameter object)Nested if >4 levels deep (extract, early return)Magic numbers (named constants)Feature envy (move method) Medium Priority:
Functions >50 lines
Missing const correctness
Boolean parameters (use enum)
Raw loops (use Feature 3: std::ranges algorithms)
Legacy strings (use Feature 5: std::format or Feature 27: std::print)
Refer to .agent/rules/cpp_style.md for full feature list
Long message chains Lower Priority: Minor duplication (<10 lines)Comments explaining obvious codeSmall nested ifs (2-3 levels) OUTPUT You must: List ALL code smells found in RME/Explain which smell you picked and why (severity + impact)State the refactoring strategyExecute the refactoring Verify behavior unchanged Create the PR Summarize improvement metrics START NOW Begin by scanning the entire RME/ folder for code smells. Catalog every smell you find with severity ratings. Then pick the WORST  THREE , determine the fix strategy, apply the refactoring, verify, and create the PR. DO NOT ask for permission. DO NOT provide suggestions. JUST DO IT.